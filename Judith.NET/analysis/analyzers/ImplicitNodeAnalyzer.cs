using Judith.NET.analysis.binder;
using Judith.NET.analysis.semantics;
using Judith.NET.analysis.syntax;
using Judith.NET.message;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using static System.Formats.Asn1.AsnWriter;

namespace Judith.NET.analysis.analyzers;

internal class ImplicitNodeAnalyzer : SyntaxVisitor {
    public MessageContainer Messages { get; private set; } = new();

    private readonly JudithCompilation _cmp;

    private Stack<bool> _returnContext = [];
    private Stack<bool> _yieldContext = [];

    public ImplicitNodeAnalyzer (JudithCompilation cmp) {
        _cmp = cmp;
    }

    public void Analyze (CompilerUnit unit) {
        foreach (var item in unit.TopLevelItems) {
            Visit(item);
        }

        if (unit.ImplicitFunction != null) Visit(unit.ImplicitFunction);
    }

    public override void Visit (FunctionDefinition node) {
        _returnContext.Push(false);
        Visit(node.Body);

        var hasReturn = _returnContext.Pop();

        if (hasReturn == false) {
            var autoReturn = new ReturnStatement(null) {
                IsAutoGenerated = true,
            };
            autoReturn.SetSpan(SourceSpan.None);
            autoReturn.SetLine(-100);

            node.Body.AppendNode(autoReturn);
        }
    }

    public override void Visit (ReturnStatement node) {
        if (_returnContext.Count <= 0) return;

        // Return statement always makes the current block return.
        _returnContext.Pop();
        _returnContext.Push(true);
    }

    public override void Visit (IfExpression node) {
        if (_returnContext.Count <= 0) return;

        // If expression is return if both of its blocks are return.
        _returnContext.Push(false);
        Visit(node.Consequent);
        bool ifReturns = _returnContext.Pop();

        if (node.Alternate == null) {
            ifReturns = false;
        }
        else {
            _returnContext.Push(false);
            Visit(node.Alternate);
            ifReturns = ifReturns && _returnContext.Pop();
        }

        _returnContext.Pop();
        _returnContext.Push(ifReturns);
    }

    public override void Visit (WhileExpression node) {
        // While expression is never a return, so we don't visit its body
        // (as it could alter the return context).
    }

    public override void Visit (LoopExpression node) {
        if (_returnContext.Count <= 0) return;

        // Loop expression is a return if its body is a return.
        Visit(node.Body);
    }

    public override void Visit (ForeachExpression node) {
        // Foreach expression is never a return, so we don't visit its body
        // (as it could alter the return context).
    }
}
